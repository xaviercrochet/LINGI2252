\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{listings}
\usepackage{times}

\pagestyle{fancy}
\lstset{
basicstyle=\footnotesize, 
breaklines=true
}
\begin{document}
\begin{titlepage}
\begin{center}
\includegraphics[width=0.15\textwidth]{UCL.png}
\vfill
\hrulefill
\\[1.2cm]
\textsc{\LARGE LINGI2252 Assignment 2 report}\\[1.2cm]
\hrulefill
\vfill
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
Group 17\\
Xiao \textsc{Xu}\\ Xavier \textsc{Crochet}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
Kim \textsc{Mens} \\
Sergio \textsc{Castro} \\
\end{flushright}
\end{minipage}
\vfill
\includegraphics[width=0.30\textwidth]{EPL.jpg}\\
\vfill
\end{center}
\end{titlepage}


\tableofcontents
\newpage
\section{Introduction}
In the first report, we try to do a manual analysis of \textit{Glamour}. This first step gives us a global overview of \textit{Glamour} and helps us to understand how \textit{Moose} and his tools works. Because of the size of the system (about 270 classes), we use some tools in order to get some hints on where to begin. It wasn't exactly what was asked in the statement of the first report but now that we have all the tools in our hand, we can start looking more effectively for the needles in the haystack that Glamour is.\\

Moreover, we found some code duplication in the source code (but relatively few compared to the size of the framework) and the utilisation  of the \textit{Patern Obeserver} in the GLMPresentation class. We thus conclude that Glmamour was globally well-designed, despite the few code duplication.\\

The report will be divded in two parts:
\begin{enumerate}
	\item We start by analyse the code using crieria not identifiable by metrics to see
		\begin{itemize}
		\item How well the code is commented.
		\item How good the naming convetion is.
		\end{itemize}
	\item Then, we develop a set of thresolded metrics we'll use later to analyse the code.   
 \end{enumerate}
\newpage
\section{Architecture}
\subsection{Introduction}
\subsection{Overview Pyramid}
\subsection{Complexity}
\section{Comments}
Commenting code is important to improve \textbf{readability} and  the \textbf{reusability}. It make it easier for developpers to contiue a project or for student to analyse it.\\

There is so few comments in the code that we decide to not use a metric to analyse this part. In deed, there is only 768 comments! That's about 3 comments for each class.
\section{Naming Convention}

A good naming convention is also an important point in order to imrpove \textbf{readability} and \textbf{reusability} of the code. Using the \textit{Name Cloud} utility from moose, we can display the following figure, showing the most used words \textbf{for naming classes} in the framework.\\
\includegraphics[width=\textwidth]{name_cloud}
\\
As we can see \textbf{GLM} is the suffix coming up the more often. Other suffix such as \textbf{test} \textbf{render} or \textbf{morphic} arise too. It seems that classes are named quite correcly in order to provide meta-information about their use.\\

We can perform the same analysis for methods or variable.Globally there is no bad smells coming up here. There is not randomly named classes variable or methods. Anyway, naming convention is quite a controversial issue, so we are not going deeper in the analysis here. 
\section{Metrics-based analysis}
\subsection{Introduction}
Before deciding when to refactor, we need first to identify where bad smells occurs inside the framework.Using \textit{Moose}'s metrics set, we start by etablishing criteria to indentify those parts.\\ 

In practice, we'll use the following query in order to retrieve the classes based on our thresholded metrics:\\

\begin{lstlisting}
((self flatCollect:[:each | each classes]) flatCollect:[:each | each methods]) select:[:each | (each ATTRIBUTE OPERATOR THRESHOLD)] 
\end{lstlisting}

If we want only to look into classes, we can do:\\
\begin{lstlisting}
(self flatCollect:[:each | each classes])  select:[:each | (each ATTRIBUTE OPERATOR THRESHOLD)]
\end{lstlisting}
%(MooseModel root allModels first) allClasses select: [:each | (each METRICNAME OPERATOR THRESHOLD)]
Avec
\begin{itemize}
\item ATTRIBUTE - The name of the attribute
\item OPERATOR - The operator for the comparaison
\item THRESHOLD - The value of the threshold
 \end{itemize}

\subsection{Code duplication}
Having the same code structure in more than one place in the system is quite nasty. The programm will be better if we find a way to reunite them.The attributes we have to handle are \textit{NumberOfExternalDuplications} and \textit{NumberOfInternalDuplications}.\\

\textbf{Threshold} - \textit{SmallDude}, the tool used by moose to detect duplicated code have a threshold of 3 lines. We decide here to set the threshold of the two attributes to 0, and to analyse one at the time the results.\\

When querying for
\begin{itemize}
\item \textit{NumberOfInternalDuplications} we get 27 classes
\item \textit{NumberOfExternalDuplications} we get 30 classes
\end{itemize}
Let's take for example the class \textit{GLMBasicExample}.
\begin{itemize}
\item We have 3 external duplications, meaning that we have 3 block of code present in three other class of the framework. The duplication with \textit{GLMUpdateInterdepententPanesTest} is the following:
\begin{lstlisting}
browser := GLMTabulator new.
browser
	column: #one;
	column: #two;
	column: #three.
(browser transmit)
	to: #one;
	andShow:[:a] a tree display:[:x|1 to: x]].
(browser transmit)
	to: #three;
	from: #two;
\end{lstlisting}
here, we can extract a new class from \textit{GLMBasicExample} and use it inside \textit{GLMUpdateInterdepententPanesTest}.

\item We have also 6 internal duplications. The following piece of code is present two times in the class.
\begin{lstlisting}
|browser model|
	model := Dictionary new.
	model at: #some put: #(1 2 3 4).
	model at: #even put: #(2 6 8).
	model at: #odd put: #(3 7 9).
	
	browser := GLMTabulator new.
	browser column: #one.
	browser transmit to: #one; andShow: [ :a |
		a tree
			display: [model keys];  
\end{lstlisting}

We can refactor the classe by extracting the duplicated blocks as new methods, making the class more maintainable.\\

Basicly, the solution is to \textbf{extract} the duplicated block as \textbf{a new method} when  an internal one occurs, and as a \textbf{new class} when it's an external. When a external duplicated block occurs between \textbf{two parent classes}, it's more appropriate to resolve it using \textbf{inheritance}. 
\end{itemize}	
\subsection{Cohesion}
Cohesion metrics measure how well the methods of a class are related to each other. A cohesive class performs one function. A non-cohesive class performs two or more unrelated functions. The idea is to refactor the non-cohesive class into several smaller classes. Cohesion is thus a good thing.

The attribute to inspect here is \textit{tightClassCohesion}. It's a ratio between number of connected methods and the maximum number of possibly connected methods. Two methods are connected if they access the same attribute. 
We modify our query a little bit:
\begin{lstlisting}
(self flatCollect:[:each | each classes])  select:[:each | ((each tightClassCohesion  >= MIN) &( each tightClassCohesion < MAX))]
\end{lstlisting}

And compute the following graph, displaying the number the repartition of all the classes in term of their cohesion value.\\
\includegraphics[width=\textwidth]{cohesion_result}

\begin{itemize}
\item We see thaht the class having the highest cohesion value (1.47) is GLMUpdateMorphicTest and has only \textbf{96 lines of codes}.\\

\item About ~200 classes have less than O.1 cohesion. 
\end{itemize}

\begin{minipage}[t]{0.4\textwidth}
When we ask moose to display the concerned classes, we see that the concerned classes are the elephant one of the framework. Furthemore, the whole \textit{GLMPresensation} Family appears on the picture (as you can see in the picture to the right):

\end{minipage}
\hfill
\begin{minipage}[t]{0.6\textwidth}
    \centering
     \vspace{-1.5ex}
\includegraphics[width=0.6\textwidth]{GLMPresentation_family}
\end{minipage} 


Thoses classes (GLMPresentation, GLMListingPresentaion, GLMWizard, GLMBrowser, ...)  where also identified in the first report as elephant  classes.\\

If we query for classes having low cohesion and high line number of code, we get similar results. We reach here one of our first report conclusion. They are a lot of big classes in the framework, there is work to do on this part. One must increase those classes's cohesion by refactoring them into smaller classes.\\
 
 
\subsection{Accessors} 
\subsection{Long Method}
\subsection{Long Class}
\subsection{Long Parameter List}
\subsection{Thresolded Metrics Summary}
\subsection{...}
\section{Improvements}
\section{Conclusion}
\section{Annexes}
%http://www.arisa.se/compendium/node118.html

\end{document}
